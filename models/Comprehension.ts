/* tslint:disable */
/* eslint-disable */
/**
 * Permify API
 * Permify is an open source authorization service for creating fine-grained and scalable authorization systems.
 *
 * The version of the OpenAPI document: v0.9.9
 * Contact: hello@permify.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { Expr } from './Expr';
import {
    ExprFromJSON,
    ExprFromJSONTyped,
    ExprToJSON,
} from './Expr';

/**
 * A comprehension expression applied to a list or map.
 * 
 * Comprehensions are not part of the core syntax, but enabled with macros.
 * A macro matches a specific call signature within a parsed AST and replaces
 * the call with an alternate AST block. Macro expansion happens at parse
 * time.
 * 
 * The following macros are supported within CEL:
 * 
 * Aggregate type macros may be applied to all elements in a list or all keys
 * in a map:
 * 
 * *  `all`, `exists`, `exists_one` -  test a predicate expression against
 *    the inputs and return `true` if the predicate is satisfied for all,
 *    any, or only one value `list.all(x, x < 10)`.
 * *  `filter` - test a predicate expression against the inputs and return
 *    the subset of elements which satisfy the predicate:
 *    `payments.filter(p, p > 1000)`.
 * *  `map` - apply an expression to all elements in the input and return the
 *    output aggregate type: `[1, 2, 3].map(i, i * i)`.
 * 
 * The `has(m.x)` macro tests whether the property `x` is present in struct
 * `m`. The semantics of this macro depend on the type of `m`. For proto2
 * messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
 * macro tests whether the property is set to its default. For map and struct
 * types, the macro tests whether the property `x` is defined on `m`.
 * @export
 * @interface Comprehension
 */
export interface Comprehension {
    /**
     * The name of the iteration variable.
     * @type {string}
     * @memberof Comprehension
     */
    iterVar?: string;
    /**
     * 
     * @type {Expr}
     * @memberof Comprehension
     */
    iterRange?: Expr;
    /**
     * The name of the variable used for accumulation of the result.
     * @type {string}
     * @memberof Comprehension
     */
    accuVar?: string;
    /**
     * 
     * @type {Expr}
     * @memberof Comprehension
     */
    accuInit?: Expr;
    /**
     * 
     * @type {Expr}
     * @memberof Comprehension
     */
    loopCondition?: Expr;
    /**
     * 
     * @type {Expr}
     * @memberof Comprehension
     */
    loopStep?: Expr;
    /**
     * 
     * @type {Expr}
     * @memberof Comprehension
     */
    result?: Expr;
}

/**
 * Check if a given object implements the Comprehension interface.
 */
export function instanceOfComprehension(value: object): value is Comprehension {
    return true;
}

export function ComprehensionFromJSON(json: any): Comprehension {
    return ComprehensionFromJSONTyped(json, false);
}

export function ComprehensionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Comprehension {
    if (json == null) {
        return json;
    }
    return {
        
        'iterVar': json['iterVar'] == null ? undefined : json['iterVar'],
        'iterRange': json['iterRange'] == null ? undefined : ExprFromJSON(json['iterRange']),
        'accuVar': json['accuVar'] == null ? undefined : json['accuVar'],
        'accuInit': json['accuInit'] == null ? undefined : ExprFromJSON(json['accuInit']),
        'loopCondition': json['loopCondition'] == null ? undefined : ExprFromJSON(json['loopCondition']),
        'loopStep': json['loopStep'] == null ? undefined : ExprFromJSON(json['loopStep']),
        'result': json['result'] == null ? undefined : ExprFromJSON(json['result']),
    };
}

export function ComprehensionToJSON(value?: Comprehension | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'iterVar': value['iterVar'],
        'iterRange': ExprToJSON(value['iterRange']),
        'accuVar': value['accuVar'],
        'accuInit': ExprToJSON(value['accuInit']),
        'loopCondition': ExprToJSON(value['loopCondition']),
        'loopStep': ExprToJSON(value['loopStep']),
        'result': ExprToJSON(value['result']),
    };
}

