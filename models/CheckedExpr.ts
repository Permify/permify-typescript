/* tslint:disable */
/* eslint-disable */
/**
 * Permify API
 * Permify is an open source authorization service for creating fine-grained and scalable authorization systems.
 *
 * The version of the OpenAPI document: v0.9.9
 * Contact: hello@permify.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { Expr } from './Expr';
import {
    ExprFromJSON,
    ExprFromJSONTyped,
    ExprToJSON,
} from './Expr';
import type { SourceInfo } from './SourceInfo';
import {
    SourceInfoFromJSON,
    SourceInfoFromJSONTyped,
    SourceInfoToJSON,
} from './SourceInfo';
import type { V1alpha1Type } from './V1alpha1Type';
import {
    V1alpha1TypeFromJSON,
    V1alpha1TypeFromJSONTyped,
    V1alpha1TypeToJSON,
} from './V1alpha1Type';
import type { V1alpha1Reference } from './V1alpha1Reference';
import {
    V1alpha1ReferenceFromJSON,
    V1alpha1ReferenceFromJSONTyped,
    V1alpha1ReferenceToJSON,
} from './V1alpha1Reference';

/**
 * A CEL expression which has been successfully type checked.
 * @export
 * @interface CheckedExpr
 */
export interface CheckedExpr {
    /**
     * A map from expression ids to resolved references.
     * 
     * The following entries are in this table:
     * 
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * @type {{ [key: string]: V1alpha1Reference; }}
     * @memberof CheckedExpr
     */
    referenceMap?: { [key: string]: V1alpha1Reference; };
    /**
     * A map from expression ids to types.
     * 
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * @type {{ [key: string]: V1alpha1Type; }}
     * @memberof CheckedExpr
     */
    typeMap?: { [key: string]: V1alpha1Type; };
    /**
     * 
     * @type {SourceInfo}
     * @memberof CheckedExpr
     */
    sourceInfo?: SourceInfo;
    /**
     * The expr version indicates the major / minor version number of the `expr`
     * representation.
     * 
     * The most common reason for a version change will be to indicate to the CEL
     * runtimes that transformations have been performed on the expr during static
     * analysis. In some cases, this will save the runtime the work of applying
     * the same or similar transformations prior to evaluation.
     * @type {string}
     * @memberof CheckedExpr
     */
    exprVersion?: string;
    /**
     * 
     * @type {Expr}
     * @memberof CheckedExpr
     */
    expr?: Expr;
}

/**
 * Check if a given object implements the CheckedExpr interface.
 */
export function instanceOfCheckedExpr(value: object): value is CheckedExpr {
    return true;
}

export function CheckedExprFromJSON(json: any): CheckedExpr {
    return CheckedExprFromJSONTyped(json, false);
}

export function CheckedExprFromJSONTyped(json: any, ignoreDiscriminator: boolean): CheckedExpr {
    if (json == null) {
        return json;
    }
    return {
        
        'referenceMap': json['referenceMap'] == null ? undefined : (mapValues(json['referenceMap'], V1alpha1ReferenceFromJSON)),
        'typeMap': json['typeMap'] == null ? undefined : (mapValues(json['typeMap'], V1alpha1TypeFromJSON)),
        'sourceInfo': json['sourceInfo'] == null ? undefined : SourceInfoFromJSON(json['sourceInfo']),
        'exprVersion': json['exprVersion'] == null ? undefined : json['exprVersion'],
        'expr': json['expr'] == null ? undefined : ExprFromJSON(json['expr']),
    };
}

export function CheckedExprToJSON(value?: CheckedExpr | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'referenceMap': value['referenceMap'] == null ? undefined : (mapValues(value['referenceMap'], V1alpha1ReferenceToJSON)),
        'typeMap': value['typeMap'] == null ? undefined : (mapValues(value['typeMap'], V1alpha1TypeToJSON)),
        'sourceInfo': SourceInfoToJSON(value['sourceInfo']),
        'exprVersion': value['exprVersion'],
        'expr': ExprToJSON(value['expr']),
    };
}

